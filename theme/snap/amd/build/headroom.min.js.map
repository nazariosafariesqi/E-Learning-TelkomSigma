{"version":3,"file":"headroom.min.js","sources":["../src/headroom.js"],"sourcesContent":["/*!\n * headroom.js v0.9.3 - Give your page some headroom. Hide your header until you need it\n * Copyright (c) 2016 Nick Williams - http://wicky.nillia.ms/headroom.js\n * License: MIT\n */\n\n(function(root, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    }\n    else if (typeof exports === 'object') {\n        // COMMONJS\n        module.exports = factory();\n    }\n    else {\n        // BROWSER\n        root.Headroom = factory();\n    }\n}(this, function() {\n    'use strict';\n\n    /* exported features */\n\n    var features = {\n        bind : !!(function(){}.bind),\n        classList : 'classList' in document.documentElement,\n        rAF : !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)\n    };\n    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\n    /**\n     * Handles debouncing of events via requestAnimationFrame\n     * @see http://www.html5rocks.com/en/tutorials/speed/animations/\n     * @param {Function} callback The callback to handle whichever event\n     */\n    function Debouncer (callback) {\n        this.callback = callback;\n        this.ticking = false;\n    }\n    Debouncer.prototype = {\n        constructor : Debouncer,\n\n        /**\n         * dispatches the event to the supplied callback\n         * @private\n         */\n        update : function() {\n            this.callback && this.callback();\n            this.ticking = false;\n        },\n\n        /**\n         * ensures events don't get stacked\n         * @private\n         */\n        requestTick : function() {\n            if(!this.ticking) {\n                requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));\n                this.ticking = true;\n            }\n        },\n\n        /**\n         * Attach this as the event listeners\n         */\n        handleEvent : function() {\n            this.requestTick();\n        }\n    };\n    /**\n     * Check if object is part of the DOM\n     * @constructor\n     * @param {Object} obj element to check\n     */\n    function isDOMElement(obj) {\n        return obj && typeof window !== 'undefined' && (obj === window || obj.nodeType);\n    }\n\n    /**\n     * Helper function for extending objects\n     */\n    function extend (object /*, objectN ... */) {\n        if(arguments.length <= 0) {\n            throw new Error('Missing arguments in extend function');\n        }\n\n        var result = object || {},\n            key,\n            i;\n\n        for (i = 1; i < arguments.length; i++) {\n            var replacement = arguments[i] || {};\n\n            for (key in replacement) {\n                // Recurse into object except if the object is a DOM element\n                if(typeof result[key] === 'object' && ! isDOMElement(result[key])) {\n                    result[key] = extend(result[key], replacement[key]);\n                }\n                else {\n                    result[key] = result[key] || replacement[key];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Helper function for normalizing tolerance option to object format\n     */\n    function normalizeTolerance (t) {\n        return t === Object(t) ? t : { down : t, up : t };\n    }\n\n    /**\n     * UI enhancement for fixed headers.\n     * Hides header when scrolling down\n     * Shows header when scrolling up\n     * @constructor\n     * @param {DOMElement} elem the header element\n     * @param {Object} options options for the widget\n     */\n    function Headroom (elem, options) {\n        options = extend(options, Headroom.options);\n\n        this.lastKnownScrollY = 0;\n        this.elem             = elem;\n        this.tolerance        = normalizeTolerance(options.tolerance);\n        this.classes          = options.classes;\n        this.offset           = options.offset;\n        this.scroller         = options.scroller;\n        this.initialised      = false;\n        this.onPin            = options.onPin;\n        this.onUnpin          = options.onUnpin;\n        this.onTop            = options.onTop;\n        this.onNotTop         = options.onNotTop;\n        this.onBottom         = options.onBottom;\n        this.onNotBottom      = options.onNotBottom;\n    }\n    Headroom.prototype = {\n        constructor : Headroom,\n\n        /**\n         * Initialises the widget\n         */\n        init : function() {\n            if(!Headroom.cutsTheMustard) {\n                return;\n            }\n\n            this.debouncer = new Debouncer(this.update.bind(this));\n            this.elem.classList.add(this.classes.initial);\n\n            // defer event registration to handle browser\n            // potentially restoring previous scroll position\n            setTimeout(this.attachEvent.bind(this), 100);\n\n            return this;\n        },\n\n        /**\n         * Unattaches events and removes any classes that were added\n         */\n        destroy : function() {\n            var classes = this.classes;\n\n            this.initialised = false;\n            this.elem.classList.remove(classes.unpinned, classes.pinned, classes.top, classes.notTop, classes.initial);\n            this.scroller.removeEventListener('scroll', this.debouncer, false);\n        },\n\n        /**\n         * Attaches the scroll event\n         * @private\n         */\n        attachEvent : function() {\n            if(!this.initialised){\n                this.lastKnownScrollY = this.getScrollY();\n                this.initialised = true;\n                this.scroller.addEventListener('scroll', this.debouncer, false);\n\n                this.debouncer.handleEvent();\n            }\n        },\n\n        /**\n         * Unpins the header if it's currently pinned\n         */\n        unpin : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {\n                classList.add(classes.unpinned);\n                classList.remove(classes.pinned);\n                this.onUnpin && this.onUnpin.call(this);\n            }\n        },\n\n        /**\n         * Pins the header if it's currently unpinned\n         */\n        pin : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(classList.contains(classes.unpinned)) {\n                classList.remove(classes.unpinned);\n                classList.add(classes.pinned);\n                this.onPin && this.onPin.call(this);\n            }\n        },\n\n        /**\n         * Handles the top states\n         */\n        top : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.top)) {\n                classList.add(classes.top);\n                classList.remove(classes.notTop);\n                this.onTop && this.onTop.call(this);\n            }\n        },\n\n        /**\n         * Handles the not top state\n         */\n        notTop : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.notTop)) {\n                classList.add(classes.notTop);\n                classList.remove(classes.top);\n                this.onNotTop && this.onNotTop.call(this);\n            }\n        },\n\n        bottom : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.bottom)) {\n                classList.add(classes.bottom);\n                classList.remove(classes.notBottom);\n                this.onBottom && this.onBottom.call(this);\n            }\n        },\n\n        /**\n         * Handles the not top state\n         */\n        notBottom : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.notBottom)) {\n                classList.add(classes.notBottom);\n                classList.remove(classes.bottom);\n                this.onNotBottom && this.onNotBottom.call(this);\n            }\n        },\n\n        /**\n         * Gets the Y scroll position\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n         * @return {Number} pixels the page has scrolled along the Y-axis\n         */\n        getScrollY : function() {\n            return (this.scroller.pageYOffset !== undefined)\n                ? this.scroller.pageYOffset\n                : (this.scroller.scrollTop !== undefined)\n                ? this.scroller.scrollTop\n                : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n        },\n\n        /**\n         * Gets the height of the viewport\n         * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript\n         * @return {int} the height of the viewport in pixels\n         */\n        getViewportHeight : function () {\n            return window.innerHeight\n                || document.documentElement.clientHeight\n                || document.body.clientHeight;\n        },\n\n        /**\n         * Gets the physical height of the DOM element\n         * @param  {Object}  elm the element to calculate the physical height of which\n         * @return {int}     the physical height of the element in pixels\n         */\n        getElementPhysicalHeight : function (elm) {\n            return Math.max(\n                elm.offsetHeight,\n                elm.clientHeight\n            );\n        },\n\n        /**\n         * Gets the physical height of the scroller element\n         * @return {int} the physical height of the scroller element in pixels\n         */\n        getScrollerPhysicalHeight : function () {\n            return (this.scroller === window || this.scroller === document.body)\n                ? this.getViewportHeight()\n                : this.getElementPhysicalHeight(this.scroller);\n        },\n\n        /**\n         * Gets the height of the document\n         * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/\n         * @return {int} the height of the document in pixels\n         */\n        getDocumentHeight : function () {\n            var body = document.body,\n                documentElement = document.documentElement;\n\n            return Math.max(\n                body.scrollHeight, documentElement.scrollHeight,\n                body.offsetHeight, documentElement.offsetHeight,\n                body.clientHeight, documentElement.clientHeight\n            );\n        },\n\n        /**\n         * Gets the height of the DOM element\n         * @param  {Object}  elm the element to calculate the height of which\n         * @return {int}     the height of the element in pixels\n         */\n        getElementHeight : function (elm) {\n            return Math.max(\n                elm.scrollHeight,\n                elm.offsetHeight,\n                elm.clientHeight\n            );\n        },\n\n        /**\n         * Gets the height of the scroller element\n         * @return {int} the height of the scroller element in pixels\n         */\n        getScrollerHeight : function () {\n            return (this.scroller === window || this.scroller === document.body)\n                ? this.getDocumentHeight()\n                : this.getElementHeight(this.scroller);\n        },\n\n        /**\n         * determines if the scroll position is outside of document boundaries\n         * @param  {int}  currentScrollY the current y scroll position\n         * @return {bool} true if out of bounds, false otherwise\n         */\n        isOutOfBounds : function (currentScrollY) {\n            var pastTop  = currentScrollY < 0,\n                pastBottom = currentScrollY + this.getScrollerPhysicalHeight() > this.getScrollerHeight();\n\n            return pastTop || pastBottom;\n        },\n\n        /**\n         * determines if the tolerance has been exceeded\n         * @param  {int} currentScrollY the current scroll y position\n         * @return {bool} true if tolerance exceeded, false otherwise\n         */\n        toleranceExceeded : function (currentScrollY, direction) {\n            return Math.abs(currentScrollY-this.lastKnownScrollY) >= this.tolerance[direction];\n        },\n\n        /**\n         * determine if it is appropriate to unpin\n         * @param  {int} currentScrollY the current y scroll position\n         * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n         * @return {bool} true if should unpin, false otherwise\n         */\n        shouldUnpin : function (currentScrollY, toleranceExceeded) {\n            var scrollingDown = currentScrollY > this.lastKnownScrollY,\n                pastOffset = currentScrollY >= this.offset;\n\n            return scrollingDown && pastOffset && toleranceExceeded;\n        },\n\n        /**\n         * determine if it is appropriate to pin\n         * @param  {int} currentScrollY the current y scroll position\n         * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n         * @return {bool} true if should pin, false otherwise\n         */\n        shouldPin : function (currentScrollY, toleranceExceeded) {\n            var scrollingUp  = currentScrollY < this.lastKnownScrollY,\n                pastOffset = currentScrollY <= this.offset;\n\n            return (scrollingUp && toleranceExceeded) || pastOffset;\n        },\n\n        /**\n         * Handles updating the state of the widget\n         */\n        update : function() {\n            var currentScrollY  = this.getScrollY(),\n                scrollDirection = currentScrollY > this.lastKnownScrollY ? 'down' : 'up',\n                toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);\n\n            if(this.isOutOfBounds(currentScrollY)) { // Ignore bouncy scrolling in OSX\n                return;\n            }\n\n            if (currentScrollY <= this.offset ) {\n                this.top();\n            } else {\n                this.notTop();\n            }\n\n            if(currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {\n                this.bottom();\n            }\n            else {\n                this.notBottom();\n            }\n\n            if(this.shouldUnpin(currentScrollY, toleranceExceeded)) {\n                this.unpin();\n            }\n            else if(this.shouldPin(currentScrollY, toleranceExceeded)) {\n                this.pin();\n            }\n\n            this.lastKnownScrollY = currentScrollY;\n        }\n    };\n    /**\n     * Default options\n     * @type {Object}\n     */\n    Headroom.options = {\n        tolerance : {\n            up : 0,\n            down : 0\n        },\n        offset : 0,\n        scroller: window,\n        classes : {\n            pinned : 'headroom--pinned',\n            unpinned : 'headroom--unpinned',\n            top : 'headroom--top',\n            notTop : 'headroom--not-top',\n            bottom : 'headroom--bottom',\n            notBottom : 'headroom--not-bottom',\n            initial : 'headroom'\n        }\n    };\n    Headroom.cutsTheMustard = typeof features !== 'undefined' && features.rAF && features.bind && features.classList;\n\n    return Headroom;\n}));\n"],"names":["root","factory","this","features","bind","classList","document","documentElement","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","Debouncer","callback","ticking","isDOMElement","obj","nodeType","extend","object","arguments","length","Error","key","i","result","replacement","_typeof","Headroom","elem","options","t","lastKnownScrollY","tolerance","Object","down","up","classes","offset","scroller","initialised","onPin","onUnpin","onTop","onNotTop","onBottom","onNotBottom","prototype","constructor","update","requestTick","rafCallback","handleEvent","init","cutsTheMustard","debouncer","add","initial","setTimeout","attachEvent","destroy","remove","unpinned","pinned","top","notTop","removeEventListener","getScrollY","addEventListener","unpin","contains","call","pin","bottom","notBottom","undefined","pageYOffset","scrollTop","body","parentNode","getViewportHeight","innerHeight","clientHeight","getElementPhysicalHeight","elm","Math","max","offsetHeight","getScrollerPhysicalHeight","getDocumentHeight","scrollHeight","getElementHeight","getScrollerHeight","isOutOfBounds","currentScrollY","pastTop","pastBottom","toleranceExceeded","direction","abs","shouldUnpin","scrollingDown","pastOffset","shouldPin","scrollingUp","scrollDirection","define","amd","exports","module"],"mappings":"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"}